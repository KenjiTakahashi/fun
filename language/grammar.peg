Fun =
 Statement*

Statement
 = XML _T
 / _ declaration:Declaration _T
   { return declaration; }
 / _ ifElse:IfElse _T
   { return ifElse }
 / _ value:InlineValue _T
   { return {type:'INLINE_VALUE', value: value}; }
 / _ reference:Reference _T
   { return reference; }
 / Comment
   { return [] }

MutationStatement
 = 'set' _ target:Reference _ '=' _ value:MutationValue
   { return {type:'MUTATION', target:target, value:value}; }

MutationValue
 = Reference
 / InlineValue

Comment "Comment"
 = _ '//' [^\n]*

/************************
 * If/Else & Conditions *
 ************************/
IfElse "If/Else statement"
 = 'if' _ '(' _ cond:Condition _ ')' _ '{' ifTrue:Fun '}' _ 'else' _ '{' ifFalse:Fun '}'
   { return {type:'IF_ELSE', condition:cond, ifTrue:ifTrue, ifFalse:ifFalse}; }

Condition
 = left:Reference _ comparison:Comparison _ right:Reference
   { return {type:'CONDITION', left:left, right:right, comparison:comparison }; }

Comparison
 = '>='
 / '>'
 / '<='
 / '<'
 / '=='

Declaration "Declaration"
 = 'let' _ name:Name _ '=' _ value:ReferenceDeclaration 
   { return {type:'DECLARATION', name:name, value:value}; }

InlineValue "Inline value"
 = String
 / Number

ReferenceDeclaration
 = Handler
 / String
 / Number
 / JSON

Handler "Handler"
 = 'handler' _ '(' _ args:ArgumentList _ ')' _ '{' _ code:FunMutations _ '}'
   { return {type:'HANDLER', args: args, code: code}; }

ArgumentList
 = name:Name _ ',' _ args:ArgumentList
   { return [name].concat(args) }
 / name:Name
   { return [name] }
 / _
   { return [] }

Name "Declaration name"
 = first:alpha rest:alphanum*
   { return first + rest.join('') }

Reference "Declaration reference"
 = String
 / Number
 / JSON
 / "Local." name:Name
   { return {type:'REFERENCE', referenceType:'LOCAL', value:name}; }
 / "Global." name:Name
   { return {type:'REFERENCE', referenceType:'GLOBAL', value:name}; }
 / name:Name
   { return {type:'REFERENCE', referenceType:'ALIAS', name:name}; }

String "String"
 = '"' value:[^"\n]+ '"'
   { return {type:'STRING', value:value.join('')}; }
 / "'" value:[^'\n]+ "'"
   { return {type:'STRING', value:value.join('')}; }

Number "Number"
 = value:[0-9]+
   { return {type:'NUMBER', value:parseInt(value.join(''))}; }

/********
 * JSON *
 ********/
JSON "JSON"
 = "{" _ values:JSONContent _ "}"
   { return {type:'JSON', content:values}; }
 / "{" _ "}"
   { return {type:'JSON', content:null}; }

JSONContent
 = kvp:JSONPair _ "," _ json:JSONContent
   { json[kvp.key]=kvp.value; return json; }
 / kvp:JSONPair
   { var json={}; json[kvp.key]=kvp.value; return json; }

JSONPair
 = key:Name _ ":" _ value:Reference
   { return {key:key,value:value}; }

/*******
 * XML *
 *******/
XML "XML"
 = _ tag:XMLSelfClosing
   { return {type:'XML_NODE', name:tag.name, attributes:tag.attributes, content:[]}; }
 / _ openTag:XMLOpen _ content:Fun _ closeTag:XMLClose
   { return {type:'XML_NODE', name:openTag.name, attributes:openTag.attributes, content:content}; }

XMLOpen	"XML open tag"
 = '<' _ tagName:Name _ attributes:XMLAttribute* '>'
   { return {name:tagName, attributes:attributes}; }

XMLClose "XML close tag"
 = '</' tagName:Name '>'
   { return {name:tagName}; }

XMLSelfClosing "Self closing XML tag"
 = '<' tagName:Name _ attributes:XMLAttribute* '/>'
   { return {name:tagName, attributes:attributes}; }

XMLAttribute "XML node attribute"
 = name:Name "=" value:Reference _
   { return {type: 'XML_ATTRIBUTE', name:name, value:value}; }

/***********
 * Utility *
 ***********/
_ "Whitespace" = [\t\f\n ]*

_T "Possibly terminal whitespace"
 = [\t\f\n ]* EOF
 / _

EOF = !.

alpha "Alpha character" = [a-zA-Z_]
alphanum "Alpha numeric character" = [a-zA-Z0-9_]
