Fun =
 Statement*

Statement
 = XML _T
 / _ declaration:Declaration _T
   { return declaration; }
 / _ ifElse:IfElse _T
   { return ifElse }
 / _ value:InlineValue _T
   { return {type:'INLINE_VALUE', value: value}; }
 / _ reference:Reference _T
   { return reference; }
 / Comment
   { return [] }

Comment "Comment"
 = _ '//' [^\n]*

/************************
 * If/Else & Conditions *
 ************************/
IfElse "If/Else statement"
 = 'if' _ '(' _ cond:Condition _ ')' _ '{' ifTrue:Fun '}' _ 'else' _ '{' ifFalse:Fun '}'
   { return {type:'IF_ELSE', condition:cond, ifTrue:ifTrue, ifFalse:ifFalse}; }

Condition
 = left:Reference _ comparison:Comparison _ right:Reference
   { return {type:'CONDITION', left:left, right:right, comparison:comparison }; }

Comparison
 = '>='
 / '>'
 / '<='
 / '<'
 / '=='

Declaration "Declaration"
 = 'let' _ name:Name _ '=' _ value:ReferenceDeclaration 
   { return {type:'DECLARATION', name:name, value:value}; }

InlineValue "Inline value"
 = String
 / Number

ReferenceDeclaration
 = Template
 / String
 / Number

Template
 = 'template' _ '(' _ args:ArgumentList _ ')' _ '{' code:Fun '}'
   { return {type:'TEMPLATE_DEFINITION', args: args, code: code}; }

ArgumentList
 = name:Name _ ',' _ args:ArgumentList
   { return [name].concat(args) }
 / name:Name
   { return [name] }
 / _
   { return [] }

Name "Declaration name"
 = first:alpha rest:alphanum*
   { return first + rest.join('') }

Reference "Declaration reference"
 = String
 / Number
 / "Local." name:Name
   { return {type:'LOCAL_REFERENCE', value:name}; }
 / "Global." name:Name
   { return {type:'GLOBAL_REFERENCE', value:name}; }
 / name:Name
   { return {type:'REFERENCE', name:name}; }

String "String"
 = '"' value:[^"\n]+ '"'
   { return {type:'STRING', value:value.join('')}; }
 / "'" value:[^'\n]+ "'"
   { return {type:'STRING', value:value.join('')}; }

Number "Number"
 = value:[0-9]+
  { return {type:'NUMBER', value:parseInt(value.join(''))}; }

/*******
 * XML *
 *******/
XML "XML"
 = _ tag:XMLSelfClosing
   { return {type:'XML_NODE', name:tag.name, attributes:tag.attributes, content:[]}; }
 / _ openTag:XMLOpen _ content:Fun _ closeTag:XMLClose
   { return {type:'XML_NODE', name:openTag.name, attributes:openTag.attributes, content:content}; }

XMLOpen	"XML open tag"
 = '<' _ tagName:Name _ attributes:XMLAttribute* '>'
   { return {name:tagName, attributes:attributes}; }

XMLClose "XML close tag"
 = '</' tagName:Name '>'
   { return {name:tagName}; }

XMLSelfClosing "Self closing XML tag"
 = '<' tagName:Name _ attributes:XMLAttribute* '/>'
   { return {name:tagName, attributes:attributes}; }

XMLAttribute "XML node attribute"
 = name:Name "=" value:String _
   { return {type: 'XML_ATTRIBUTES', name:name, value:value}; }

/***********
 * Utility *
 ***********/
_ "Whitespace" = [\t\f\n ]*

_T "Possibly terminal whitespace"
 = [\t\f\n ]* EOF
 / _

EOF = !.

alpha "Alpha character" = [a-zA-Z]
alphanum "Alpha numeric character" = [a-zA-Z0-9]
